# Polkadot Integration Guide

**File**: p0s8f3.md  
**SCIS Version**: 4.1  
**Last Updated**: November 11, 2025  
**Status**: Active

---

## Table of Contents

1. [Integration Overview](#integration-overview)
2. [Network Configuration](#network-configuration)
3. [Wallet Connection](#wallet-connection)
4. [On-Chain Storage](#on-chain-storage)
5. [Transaction Management](#transaction-management)
6. [Error Handling](#error-handling)
7. [Testing Guide](#testing-guide)
8. [Future Enhancements](#future-enhancements)

---

## Integration Overview

### Why Polkadot?

Our platform uses Polkadot blockchain for user data sovereignty, demonstrating that Web3 can deliver practical utility beyond cryptocurrency. Here's why Polkadot was chosen:

**1. User Data Sovereignty**

- Users control their own preference data
- No central server vulnerability
- Transparent data storage and access

**2. Cross-Device Synchronization**

- Preferences stored on-chain
- Accessible from any device with wallet
- No account creation required

**3. Scalable Architecture**

- Parachain ecosystem supports growth
- Off-chain workers for computation
- Cross-chain interoperability (future)

**4. Developer Experience**

- Excellent JavaScript/TypeScript support (Polkadot.js)
- Well-documented APIs
- Active community and ecosystem

### Integration Scope

**Current PoC Implementation**:

- ✅ Wallet connection (Polkadot.js extension)
- ✅ User preference storage on Westend testnet
- ✅ Preference retrieval and sync
- ✅ Transaction signing and submission

**Future Enhancements**:

- Custom parachain for discovery protocol
- Creator reputation and staking
- Decentralized content indexing
- Cross-chain content aggregation
- Off-chain workers for ML inference

---

## Network Configuration

### Supported Networks

#### Westend Testnet (Primary)

```javascript
// p0s1f1.js - Configuration
const POLKADOT_CONFIG = {
  network: "westend",
  rpcUrl: "wss://westend-rpc.polkadot.io",
  chainName: "Westend",
  decimals: 12,
  symbol: "WND",
  blockExplorer: "https://westend.subscan.io",
};
```

**Characteristics**:

- **Purpose**: Primary testnet for PoC
- **Faucet**: https://faucet.polkadot.io/westend
- **Free Tokens**: Request WND for transaction fees
- **Stability**: High uptime, production-like environment
- **Reset**: Never (data persists)

#### Rococo Testnet (Alternative)

```javascript
const ROCOCO_CONFIG = {
  network: "rococo",
  rpcUrl: "wss://rococo-rpc.polkadot.io",
  chainName: "Rococo",
  decimals: 12,
  symbol: "ROC",
};
```

**Characteristics**:

- **Purpose**: Parachain testing
- **Use When**: Testing cross-chain features (future)
- **Faucet**: https://faucet.polkadot.io/rococo

### Environment Setup

**Development Environment**:

```javascript
// .env.development
VITE_POLKADOT_NETWORK=westend
VITE_POLKADOT_RPC=wss://westend-rpc.polkadot.io
VITE_ENABLE_POLKADOT=true
VITE_LOG_LEVEL=debug
```

**Production Environment**:

```javascript
// .env.production
VITE_POLKADOT_NETWORK=westend
VITE_POLKADOT_RPC=wss://westend-rpc.polkadot.io
VITE_ENABLE_POLKADOT=true
VITE_LOG_LEVEL=error
```

---

## Wallet Connection

### Supported Wallets

1. **Polkadot.js Extension** (Primary)
   - Chrome/Firefox/Brave extension
   - Install: https://polkadot.js.org/extension/
   - Most widely used

2. **Talisman** (Recommended)
   - User-friendly interface
   - Multi-chain support
   - Install: https://talisman.xyz/

3. **SubWallet**
   - Mobile-friendly
   - Portfolio tracking
   - Install: https://subwallet.app/

### Connection Flow

```javascript
// p0s0f6.js - Cp0s0f6.1 (PolkadotConnector)

import {
  web3Accounts,
  web3Enable,
  web3FromAddress,
} from "@polkadot/extension-dapp";
import { ApiPromise, WsProvider } from "@polkadot/api";

class PolkadotConnector {
  constructor(config) {
    this.config = config;
    this.api = null;
    this.accounts = [];
    this.selectedAccount = null;
  }

  // Step 1: Connect to blockchain
  async connect() {
    try {
      const provider = new WsProvider(this.config.rpcUrl);
      this.api = await ApiPromise.create({ provider });

      // Wait for API to be ready
      await this.api.isReady;

      console.log(`✓ Connected to ${this.config.network}`);
      return true;
    } catch (error) {
      console.error("Connection failed:", error);
      throw new Error(`Failed to connect to ${this.config.network}`);
    }
  }

  // Step 2: Request wallet access
  async enableWallet() {
    try {
      // Request access to all extensions
      const extensions = await web3Enable("Polkadot Discovery");

      if (extensions.length === 0) {
        throw new Error("NO_EXTENSION_FOUND");
      }

      console.log(`✓ Found ${extensions.length} wallet(s)`);
      return extensions;
    } catch (error) {
      console.error("Wallet enable failed:", error);
      throw error;
    }
  }

  // Step 3: Get accounts from wallet
  async getAccounts() {
    try {
      this.accounts = await web3Accounts();

      if (this.accounts.length === 0) {
        throw new Error("NO_ACCOUNTS_FOUND");
      }

      console.log(`✓ Found ${this.accounts.length} account(s)`);
      return this.accounts;
    } catch (error) {
      console.error("Get accounts failed:", error);
      throw error;
    }
  }

  // Step 4: Select account
  selectAccount(account) {
    this.selectedAccount = account;
    console.log(`✓ Selected account: ${account.address}`);
  }

  // Get injector for signing
  async getInjector(address) {
    return await web3FromAddress(address);
  }

  // Check if connected
  isConnected() {
    return this.api && this.api.isConnected;
  }

  // Disconnect
  async disconnect() {
    if (this.api) {
      await this.api.disconnect();
      this.api = null;
      this.accounts = [];
      this.selectedAccount = null;
      console.log("✓ Disconnected");
    }
  }
}
```

### React Component Integration

```javascript
// p1s0f5.jsx - Cp1s0f5.1 (WalletConnect)

import React, { useState, useEffect } from "react";
import { PolkadotAPI } from "../p1s3f2";

export function WalletConnect() {
  const [status, setStatus] = useState("disconnected"); // disconnected | connecting | connected
  const [accounts, setAccounts] = useState([]);
  const [selectedAccount, setSelectedAccount] = useState(null);
  const [error, setError] = useState(null);

  const polkadotAPI = new PolkadotAPI();

  const connectWallet = async () => {
    setStatus("connecting");
    setError(null);

    try {
      // Connect to chain
      await polkadotAPI.connect();

      // Enable wallet extension
      await polkadotAPI.enableWallet();

      // Get accounts
      const accts = await polkadotAPI.getAccounts();
      setAccounts(accts);

      // Auto-select first account
      if (accts.length > 0) {
        setSelectedAccount(accts[0]);
        polkadotAPI.selectAccount(accts[0]);
      }

      setStatus("connected");
    } catch (err) {
      setError(err.message);
      setStatus("disconnected");
    }
  };

  const handleAccountSelect = (account) => {
    setSelectedAccount(account);
    polkadotAPI.selectAccount(account);
  };

  return (
    <div className="wallet-connect">
      {status === "disconnected" && (
        <button onClick={connectWallet} className="btn-primary">
          Connect Wallet
        </button>
      )}

      {status === "connecting" && <div className="loading">Connecting...</div>}

      {status === "connected" && (
        <div className="connected-state">
          <div className="account-selector">
            <label>Select Account:</label>
            <select
              value={selectedAccount?.address}
              onChange={(e) => {
                const account = accounts.find(
                  (a) => a.address === e.target.value,
                );
                handleAccountSelect(account);
              }}
            >
              {accounts.map((account) => (
                <option key={account.address} value={account.address}>
                  {account.meta.name || "Account"} (
                  {account.address.slice(0, 8)}...)
                </option>
              ))}
            </select>
          </div>

          <div className="account-info">
            <p>Address: {selectedAccount?.address}</p>
            <p>Network: Westend Testnet</p>
          </div>
        </div>
      )}

      {error && (
        <div className="error">
          {error === "NO_EXTENSION_FOUND" && (
            <p>
              No Polkadot wallet found. Please install{" "}
              <a href="https://polkadot.js.org/extension/" target="_blank">
                Polkadot.js Extension
              </a>
            </p>
          )}
          {error === "NO_ACCOUNTS_FOUND" && (
            <p>No accounts found. Please create an account in your wallet.</p>
          )}
          {error !== "NO_EXTENSION_FOUND" && error !== "NO_ACCOUNTS_FOUND" && (
            <p>Error: {error}</p>
          )}
        </div>
      )}
    </div>
  );
}
```

---

## On-Chain Storage

### Storage Schema

**User Preferences Structure**:

```javascript
const userPreferences = {
  version: 1, // Schema version for future migrations
  user_account: "5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY",
  preferences: {
    topics: ["movies", "restaurants"],
    active_filters: {
      movies: ["mov_filter_1", "mov_filter_3"],
      restaurants: ["rest_filter_1", "rest_filter_2", "rest_filter_3"],
    },
    newsletter_frequency: "weekly",
    notification_enabled: true,
    last_updated: "2025-11-11T10:04:18.123Z",
  },
  metadata: {
    created_at: "2025-11-01T00:00:00Z",
    update_count: 5,
    client_version: "0.1.0",
  },
};
```

### Writing to Chain

```javascript
// p0s0f6.js - Cp0s0f6.2 (PreferenceStorage)

class PreferenceStorage {
  constructor(api, connector) {
    this.api = api;
    this.connector = connector;
  }

  async savePreferences(preferences) {
    try {
      const account = this.connector.selectedAccount;
      if (!account) {
        throw new Error("NO_ACCOUNT_SELECTED");
      }

      // Get injector for signing
      const injector = await this.connector.getInjector(account.address);

      // Prepare data
      const data = JSON.stringify(preferences);
      const dataBytes = new TextEncoder().encode(data);

      // Create extrinsic (using system.remark for PoC)
      // In production, use custom pallet
      const extrinsic = this.api.tx.system.remark(dataBytes);

      // Estimate fees
      const info = await extrinsic.paymentInfo(account.address);
      console.log(`Estimated fee: ${info.partialFee.toHuman()}`);

      // Sign and send
      const result = await new Promise((resolve, reject) => {
        extrinsic
          .signAndSend(
            account.address,
            { signer: injector.signer },
            ({ status, events, dispatchError }) => {
              if (status.isInBlock) {
                console.log(`✓ Included in block: ${status.asInBlock.toHex()}`);
              }

              if (status.isFinalized) {
                console.log(`✓ Finalized: ${status.asFinalized.toHex()}`);

                if (dispatchError) {
                  if (dispatchError.isModule) {
                    const decoded = this.api.registry.findMetaError(
                      dispatchError.asModule,
                    );
                    reject(
                      new Error(
                        `${decoded.section}.${decoded.name}: ${decoded.docs}`,
                      ),
                    );
                  } else {
                    reject(new Error(dispatchError.toString()));
                  }
                } else {
                  resolve({
                    blockHash: status.asFinalized.toHex(),
                    success: true,
                  });
                }
              }
            },
          )
          .catch(reject);
      });

      console.log("✓ Preferences saved on-chain");
      return result;
    } catch (error) {
      console.error("Save preferences failed:", error);
      throw error;
    }
  }

  async loadPreferences(accountAddress) {
    try {
      // For PoC, we'll query recent blocks for remarks
      // In production, use custom pallet storage

      // Get recent blocks
      const blockHash = await this.api.rpc.chain.getBlockHash();
      const signedBlock = await this.api.rpc.chain.getBlock(blockHash);

      // Search for user's remarks
      for (const extrinsic of signedBlock.block.extrinsics) {
        if (
          extrinsic.method.section === "system" &&
          extrinsic.method.method === "remark" &&
          extrinsic.signer.toString() === accountAddress
        ) {
          const data = extrinsic.method.args[0].toU8a();
          const decoded = new TextDecoder().decode(data);

          try {
            const preferences = JSON.parse(decoded);
            console.log("✓ Preferences loaded from chain");
            return preferences;
          } catch (e) {
            // Not valid JSON, skip
            continue;
          }
        }
      }

      // No preferences found
      return null;
    } catch (error) {
      console.error("Load preferences failed:", error);
      throw error;
    }
  }
}
```

### Custom Pallet (Future)

For production, use a custom Substrate pallet:

```rust
// Custom pallet for user preferences
#[pallet::storage]
#[pallet::getter(fn user_preferences)]
pub type UserPreferences<T: Config> = StorageMap<
    _,
    Blake2_128Concat,
    T::AccountId,
    PreferenceData,
    ValueQuery
>;

#[derive(Encode, Decode, Clone, PartialEq, Eq, RuntimeDebug, TypeInfo)]
pub struct PreferenceData {
    pub version: u32,
    pub data: BoundedVec<u8, T::MaxDataSize>,
    pub updated_at: T::Moment,
}

#[pallet::call]
impl<T: Config> Pallet<T> {
    #[pallet::weight(10_000)]
    pub fn set_preferences(
        origin: OriginFor<T>,
        data: Vec<u8>
    ) -> DispatchResult {
        let who = ensure_signed(origin)?;

        // Validate data size
        ensure!(
            data.len() <= T::MaxDataSize::get() as usize,
            Error::<T>::DataTooLarge
        );

        // Store preferences
        UserPreferences::<T>::insert(
            &who,
            PreferenceData {
                version: 1,
                data: data.try_into().unwrap(),
                updated_at: T::TimeProvider::now()
            }
        );

        Self::deposit_event(Event::PreferencesUpdated(who));
        Ok(())
    }
}
```

---

## Transaction Management

### Transaction Lifecycle

```
1. Create Extrinsic
   ↓
2. Estimate Fees
   ↓
3. Sign Transaction (User confirms in wallet)
   ↓
4. Submit to Network
   ↓
5. Wait for Inclusion in Block
   ↓
6. Wait for Finalization
   ↓
7. Confirm Success
```

### Fee Estimation

```javascript
async estimateFee(extrinsic, address) {
  const info = await extrinsic.paymentInfo(address);

  return {
    weight: info.weight.toString(),
    class: info.class.toString(),
    partialFee: info.partialFee.toHuman(),
    partialFeeRaw: info.partialFee.toString()
  };
}
```

### Transaction Status Tracking

```javascript
async trackTransaction(extrinsic, address, signer) {
  return new Promise((resolve, reject) => {
    let unsub;

    extrinsic.signAndSend(
      address,
      { signer },
      ({ status, events, dispatchError }) => {
        console.log(`Transaction status: ${status.type}`);

        // Status updates
        if (status.isReady) {
          console.log('Ready for signing');
        }

        if (status.isBroadcast) {
          console.log('Broadcast to network');
        }

        if (status.isInBlock) {
          console.log(`In block: ${status.asInBlock.toHex()}`);

          // Check events for errors
          events.forEach(({ event }) => {
            if (this.api.events.system.ExtrinsicFailed.is(event)) {
              console.error('Extrinsic failed');
            }
            if (this.api.events.system.ExtrinsicSuccess.is(event)) {
              console.log('Extrinsic successful');
            }
          });
        }

        if (status.isFinalized) {
          console.log(`Finalized: ${status.asFinalized.toHex()}`);

          if (dispatchError) {
            reject(this.parseError(dispatchError));
          } else {
            resolve({
              blockHash: status.asFinalized.toHex(),
              events: events.map(e => e.event.toHuman())
            });
          }

          if (unsub) unsub();
        }
      }
    ).then(unsubscribe => {
      unsub = unsubscribe;
    }).catch(reject);
  });
}
```

### Batch Transactions

```javascript
// Save multiple preferences in single transaction
async saveBatchPreferences(preferencesArray) {
  const account = this.connector.selectedAccount;
  const injector = await this.connector.getInjector(account.address);

  // Create batch of remarks
  const calls = preferencesArray.map(pref => {
    const data = new TextEncoder().encode(JSON.stringify(pref));
    return this.api.tx.system.remark(data);
  });

  // Create batch extrinsic
  const batchExtrinsic = this.api.tx.utility.batch(calls);

  // Sign and send
  const result = await this.trackTransaction(
    batchExtrinsic,
    account.address,
    injector.signer
  );

  return result;
}
```

---

## Error Handling

### Common Errors

| Error                  | Cause                        | Solution                      |
| ---------------------- | ---------------------------- | ----------------------------- |
| **NO_EXTENSION_FOUND** | Wallet not installed         | Install Polkadot.js extension |
| **NO_ACCOUNTS_FOUND**  | No accounts in wallet        | Create account in wallet      |
| **USER_REJECTED**      | User cancelled transaction   | Retry or skip operation       |
| **INSUFFICIENT_FUNDS** | Not enough tokens for fees   | Get tokens from faucet        |
| **NETWORK_ERROR**      | Connection issues            | Check internet, retry         |
| **INVALID_SIGNATURE**  | Signing failed               | Reconnect wallet              |
| **DISPATCH_ERROR**     | Transaction execution failed | Check transaction parameters  |

### Error Handler Implementation

```javascript
class PolkadotErrorHandler {
  static handle(error) {
    // Extension errors
    if (error.message.includes("extension")) {
      return {
        code: "NO_EXTENSION_FOUND",
        message: "Please install a Polkadot wallet extension",
        action: "INSTALL_WALLET",
        link: "https://polkadot.js.org/extension/",
      };
    }

    // Account errors
    if (error.message.includes("accounts")) {
      return {
        code: "NO_ACCOUNTS_FOUND",
        message: "No accounts found in your wallet",
        action: "CREATE_ACCOUNT",
      };
    }

    // User rejection
    if (error.message.includes("Cancelled")) {
      return {
        code: "USER_REJECTED",
        message: "Transaction was cancelled",
        action: "RETRY",
      };
    }

    // Insufficient funds
    if (error.message.includes("Inability to pay")) {
      return {
        code: "INSUFFICIENT_FUNDS",
        message: "Insufficient funds for transaction fees",
        action: "GET_TOKENS",
        link: "https://faucet.polkadot.io/westend",
      };
    }

    // Network errors
    if (
      error.message.includes("connection") ||
      error.message.includes("timeout")
    ) {
      return {
        code: "NETWORK_ERROR",
        message: "Network connection error",
        action: "RETRY",
      };
    }

    // Generic error
    return {
      code: "UNKNOWN_ERROR",
      message: error.message || "An unknown error occurred",
      action: "CONTACT_SUPPORT",
    };
  }
}
```

### Retry Logic

```javascript
async function retryOperation(operation, maxRetries = 3, delay = 1000) {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      return await operation();
    } catch (error) {
      console.log(`Attempt ${attempt} failed: ${error.message}`);

      if (attempt === maxRetries) {
        throw error;
      }

      // Exponential backoff
      await new Promise((resolve) => setTimeout(resolve, delay * attempt));
    }
  }
}

// Usage
const preferences = await retryOperation(
  () => polkadotAPI.savePreferences(data),
  3, // 3 retries
  2000, // 2 second initial delay
);
```

---

## Testing Guide

### Local Testing

**1. Install Polkadot.js Extension**

```bash
# Chrome: https://chrome.google.com/webstore/detail/polkadot%7Bjs%7D-extension/mopnmbcafieddcagagdcbnhejhlodfdd
# Firefox: https://addons.mozilla.org/en-US/firefox/addon/polkadot-js-extension/
```

**2. Create Test Account**

- Open extension
- Click "+"
- "Create new account"
- Save seed phrase securely
- Name account "Test Account"

**3. Get Testnet Tokens**

```bash
# Visit faucet
open https://faucet.polkadot.io/westend

# Paste your address
# Click "Submit"
# Wait ~30 seconds for tokens
```

**4. Run Application**

```bash
npm install
npm run dev
# Open http://localhost:5173
```

**5. Test Workflow**

- Click "Connect Wallet"
- Select account
- Perform search
- Select filters
- Click "Save Preferences"
- Confirm transaction in wallet popup
- Wait for confirmation (10-20 seconds)
- Verify success message

### Unit Tests

```javascript
// __tests__/polkadot.test.js

import { PolkadotConnector } from "../p0s0f6";

describe("PolkadotConnector", () => {
  let connector;

  beforeEach(() => {
    connector = new PolkadotConnector(TEST_CONFIG);
  });

  test("should connect to Westend", async () => {
    await connector.connect();
    expect(connector.isConnected()).toBe(true);
  });

  test("should get accounts", async () => {
    await connector.connect();
    await connector.enableWallet();
    const accounts = await connector.getAccounts();
    expect(accounts.length).toBeGreaterThan(0);
  });

  test("should handle missing extension", async () => {
    // Mock missing extension
    jest.mock("@polkadot/extension-dapp", () => ({
      web3Enable: jest.fn().mockResolvedValue([]),
    }));

    await expect(connector.enableWallet()).rejects.toThrow(
      "NO_EXTENSION_FOUND",
    );
  });
});
```

### Integration Tests

```javascript
// __tests__/preference-storage.test.js

describe("Preference Storage", () => {
  test("should save and load preferences", async () => {
    const preferences = {
      topics: ["movies"],
      filters: { movies: ["mov_filter_1"] },
    };

    // Save
    await storage.savePreferences(preferences);

    // Load
    const loaded = await storage.loadPreferences(account.address);

    expect(loaded).toEqual(preferences);
  });

  test("should handle concurrent saves", async () => {
    const saves = [
      storage.savePreferences(pref1),
      storage.savePreferences(pref2),
      storage.savePreferences(pref3),
    ];

    const results = await Promise.all(saves);

    expect(results.every((r) => r.success)).toBe(true);
  });
});
```

---

## Future Enhancements

### 1. Custom Parachain

**Purpose**: Dedicated chain for discovery protocol

```rust
// Discovery Parachain Runtime

#[frame_support::runtime]
mod runtime {
    #[runtime::pallet_index(0)]
    pub type System = frame_system::Pallet<Runtime>;

    #[runtime::pallet_index(1)]
    pub type Timestamp = pallet_timestamp::Pallet<Runtime>;

    #[runtime::pallet_index(10)]
    pub type UserPreferences = pallet_user_preferences::Pallet<Runtime>;

    #[runtime::pallet_index(11)]
    pub type CreatorReputation = pallet_creator_reputation::Pallet<Runtime>;

    #[runtime::pallet_index(12)]
    pub type ContentIndex = pallet_content_index::Pallet<Runtime>;
}
```

### 2. Creator Reputation System

```rust
#[pallet::storage]
pub type CreatorReputation<T: Config> = StorageMap<
    _,
    Blake2_128Concat,
    T::AccountId,
    ReputationScore
>;

pub struct ReputationScore {
    pub quality: u32,
    pub consistency: u32,
    pub engagement: u32,
    pub stake: Balance,
    pub total_score: u32
}
```

### 3. Decentralized Content Index

```rust
#[pallet::storage]
pub type ContentIndex<T: Config> = StorageMap<
    _,
    Blake2_128Concat,
    ContentHash,
    ContentMetadata<T::AccountId>
>;

pub struct ContentMetadata<AccountId> {
    pub creator: AccountId,
    pub topic: Topic,
    pub quality_score: u32,
    pub indexed_at: Timestamp
}
```

### 4. Cross-Chain Aggregation

```javascript
// Aggregate content from multiple parachains
async function aggregateCrossChain(query) {
  const results = await Promise.all([
    queryParachain("discovery", query),
    queryParachain("content-hub", query),
    queryParachain("creator-network", query),
  ]);

  return mergeAndRank(results);
}
```

### 5. Off-Chain Workers for ML

```rust
fn offchain_worker(block_number: T::BlockNumber) {
    // Fetch user preferences
    let preferences = Self::get_preferences();

    // Run ML inference
    let recommendations = Self::compute_recommendations(preferences);

    // Cache results
    sp_io::offchain::local_storage_set(
        StorageKind::PERSISTENT,
        b"recommendations",
        &recommendations.encode()
    );
}
```

---

## Troubleshooting

### Common Issues

**Issue**: "Cannot connect to Westend"

```
Solution:
1. Check internet connection
2. Try alternative RPC: wss://westend.api.onfinality.io/public-ws
3. Check Westend status: https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fwestend-rpc.polkadot.io#/explorer
```

**Issue**: "Transaction failed with error: 1010: Invalid Transaction"

```
Solution:
1. Ensure account has sufficient WND tokens
2. Visit faucet: https://faucet.polkadot.io/westend
3. Wait for tokens to arrive (~30 seconds)
```

**Issue**: "Extension not found"

```
Solution:
1. Install Polkadot.js extension
2. Reload page after installation
3. Grant permission when prompted
```

**Issue**: "Transaction stuck in 'Broadcast' status"

```
Solution:
1. Wait 2-3 minutes (network may be slow)
2. If still stuck, refresh page and retry
3. Check block explorer: https://westend.subscan.io/
```

---

## Resources

### Documentation

- Polkadot.js API: https://polkadot.js.org/docs/
- Substrate Docs: https://docs.substrate.io/
- Polkadot Wiki: https://wiki.polkadot.network/

### Tools

- Polkadot.js Apps: https://polkadot.js.org/apps/
- Westend Explorer: https://westend.subscan.io/
- Westend Faucet: https://faucet.polkadot.io/westend

### Support

- Polkadot Discord: https://discord.gg/polkadot
- Stack Exchange: https://substrate.stackexchange.com/
- GitHub Issues: https://github.com/polkadot-js/api/issues

### Learning Resources

- Polkadot Beginner Guide: https://wiki.polkadot.network/docs/learn-introduction
- Substrate Tutorials: https://docs.substrate.io/tutorials/
- Polkadot.js Examples: https://polkadot.js.org/docs/api/examples

---

## Best Practices

### 1. Connection Management

**Do**:

- Create singleton API instance
- Reuse connections across components
- Handle disconnections gracefully
- Implement reconnection logic

**Don't**:

- Create multiple API instances
- Leave connections open indefinitely
- Ignore connection errors

### 2. Transaction Handling

**Do**:

- Always estimate fees before signing
- Show clear user confirmation dialogs
- Provide transaction status updates
- Handle user rejections gracefully

**Don't**:

- Submit transactions without user confirmation
- Ignore transaction errors
- Assume transactions will succeed

### 3. Security

**Do**:

- Never store private keys in app
- Use extension for all signing
- Validate all user inputs
- Sanitize data before storage

**Don't**:

- Request seed phrases from users
- Store sensitive data unencrypted
- Trust client-side validation alone

### 4. Performance

**Do**:

- Cache API queries when possible
- Batch multiple operations
- Use pagination for large datasets
- Implement loading states

**Don't**:

- Make unnecessary API calls
- Block UI during operations
- Load all data at once

### 5. User Experience

**Do**:

- Provide clear error messages
- Show transaction progress
- Offer help links
- Test with real users

**Don't**:

- Use technical jargon in errors
- Hide loading states
- Assume users understand blockchain

---

## Performance Optimization

### Connection Pooling

```javascript
class PolkadotConnectionPool {
  constructor(maxConnections = 3) {
    this.pool = [];
    this.maxConnections = maxConnections;
  }

  async getConnection(rpcUrl) {
    // Check for existing connection
    let connection = this.pool.find(
      (c) => c.rpcUrl === rpcUrl && c.isConnected,
    );

    if (!connection) {
      // Create new if under limit
      if (this.pool.length < this.maxConnections) {
        connection = await this.createConnection(rpcUrl);
        this.pool.push(connection);
      } else {
        // Reuse least recently used
        connection = this.pool[0];
        await connection.connect(rpcUrl);
      }
    }

    return connection;
  }

  async createConnection(rpcUrl) {
    const provider = new WsProvider(rpcUrl);
    const api = await ApiPromise.create({ provider });
    return { api, rpcUrl, isConnected: true, lastUsed: Date.now() };
  }
}
```

### Query Caching

```javascript
class QueryCache {
  constructor(ttl = 60000) {
    // 1 minute default
    this.cache = new Map();
    this.ttl = ttl;
  }

  async query(key, queryFn) {
    const cached = this.cache.get(key);

    if (cached && Date.now() - cached.timestamp < this.ttl) {
      return cached.data;
    }

    const data = await queryFn();
    this.cache.set(key, { data, timestamp: Date.now() });

    return data;
  }

  clear() {
    this.cache.clear();
  }
}

// Usage
const cache = new QueryCache(60000);

const balance = await cache.query(`balance:${address}`, () =>
  api.query.system.account(address),
);
```

### Batch Queries

```javascript
async function batchQueries(api, queries) {
  // Execute multiple queries in parallel
  const results = await Promise.all(
    queries.map(([module, method, ...args]) =>
      api.query[module][method](...args),
    ),
  );

  return results;
}

// Usage
const [balance, nonce, metadata] = await batchQueries(api, [
  ["system", "account", address],
  ["system", "accountNonce", address],
  ["system", "account", otherAddress],
]);
```

---

## Security Considerations

### Data Validation

```javascript
function validatePreferences(preferences) {
  // Schema validation
  const schema = {
    topics: Array,
    active_filters: Object,
    newsletter_frequency: ["daily", "weekly", "monthly"],
  };

  // Type checks
  if (!Array.isArray(preferences.topics)) {
    throw new Error("Invalid topics format");
  }

  // Size limits
  if (JSON.stringify(preferences).length > 10000) {
    throw new Error("Preferences too large");
  }

  // Sanitize strings
  preferences.topics = preferences.topics.map((t) =>
    t.replace(/[^\w\s-]/g, ""),
  );

  return preferences;
}
```

### Rate Limiting

```javascript
class RateLimiter {
  constructor(maxRequests = 10, windowMs = 60000) {
    this.requests = [];
    this.maxRequests = maxRequests;
    this.windowMs = windowMs;
  }

  canMakeRequest() {
    const now = Date.now();

    // Remove old requests
    this.requests = this.requests.filter((time) => now - time < this.windowMs);

    return this.requests.length < this.maxRequests;
  }

  recordRequest() {
    this.requests.push(Date.now());
  }

  async throttle(fn) {
    if (!this.canMakeRequest()) {
      throw new Error("Rate limit exceeded");
    }

    this.recordRequest();
    return await fn();
  }
}
```

### Input Sanitization

```javascript
function sanitizeInput(input) {
  return input
    .trim()
    .replace(/[<>]/g, "") // Remove HTML tags
    .substring(0, 1000); // Limit length
}

function sanitizePreferences(preferences) {
  return {
    topics: preferences.topics.map(sanitizeInput),
    active_filters: Object.fromEntries(
      Object.entries(preferences.active_filters).map(([key, value]) => [
        sanitizeInput(key),
        Array.isArray(value) ? value.map(sanitizeInput) : value,
      ]),
    ),
    newsletter_frequency: sanitizeInput(preferences.newsletter_frequency),
  };
}
```

---

## Monitoring & Logging

### Transaction Monitoring

```javascript
class TransactionMonitor {
  constructor() {
    this.transactions = new Map();
  }

  track(txHash, metadata) {
    this.transactions.set(txHash, {
      ...metadata,
      startTime: Date.now(),
      status: "pending",
    });
  }

  update(txHash, status, data) {
    const tx = this.transactions.get(txHash);
    if (tx) {
      tx.status = status;
      tx.lastUpdate = Date.now();
      tx.data = data;
    }
  }

  getStats() {
    const txs = Array.from(this.transactions.values());

    return {
      total: txs.length,
      pending: txs.filter((t) => t.status === "pending").length,
      success: txs.filter((t) => t.status === "finalized").length,
      failed: txs.filter((t) => t.status === "failed").length,
      avgTime: this.calculateAvgTime(txs),
    };
  }

  calculateAvgTime(txs) {
    const finalized = txs.filter((t) => t.status === "finalized");
    if (finalized.length === 0) return 0;

    const times = finalized.map((t) => t.lastUpdate - t.startTime);
    return times.reduce((a, b) => a + b, 0) / times.length;
  }
}
```

### Logging Strategy

```javascript
class PolkadotLogger {
  constructor(level = "info") {
    this.level = level;
    this.levels = { debug: 0, info: 1, warn: 2, error: 3 };
  }

  log(level, component, message, data) {
    if (this.levels[level] < this.levels[this.level]) return;

    const entry = {
      timestamp: new Date().toISOString(),
      level,
      component,
      message,
      data: data || {},
    };

    // Console output
    console[level](`[${entry.timestamp}] [${component}] ${message}`, data);

    // Send to logging service (future)
    this.sendToService(entry);
  }

  debug(component, message, data) {
    this.log("debug", component, message, data);
  }

  info(component, message, data) {
    this.log("info", component, message, data);
  }

  warn(component, message, data) {
    this.log("warn", component, message, data);
  }

  error(component, message, data) {
    this.log("error", component, message, data);
  }

  sendToService(entry) {
    // Send to external logging service
    // e.g., Sentry, LogRocket, etc.
  }
}

// Usage
const logger = new PolkadotLogger("debug");

logger.info("PolkadotConnector", "Connected to Westend", {
  chainName: "Westend",
  blockNumber: 12345,
});

logger.error("PreferenceStorage", "Failed to save preferences", {
  error: error.message,
  account: account.address,
});
```

---

## Conclusion

This guide provides comprehensive coverage of Polkadot integration for the Discovery Platform PoC. Key takeaways:

1. **Start Simple**: Use Westend testnet and basic storage
2. **Handle Errors**: Robust error handling is critical
3. **User Experience**: Make blockchain interactions transparent
4. **Security First**: Never compromise on security practices
5. **Plan for Scale**: Architecture supports future enhancements

For implementation details, refer to:

- **Component Implementation**: p0s0f6.js (Polkadot connector)
- **UI Components**: p1s0f5.jsx (Wallet connect)
- **API Wrapper**: p1s3f2.js (Polkadot API)
- **Architecture Overview**: p0s8f1.md
- **Project Specification**: p10s0f1.txt

---

**Document Version**: 1.0  
**Last Updated**: November 11, 2025  
**Maintained By**: Project Team  
**Questions?**: Refer to project documentation or contact support
